package com.veeja.leetCode.Q0201_Q0300;

import org.junit.Test;

/**
 * 0221. 最大正方形
 * <p>
 * 在一个由 '0' 和 '1' 组成的二维矩阵内，找到只包含 '1' 的最大正方形，并返回其面积。
 */
public class Q0221 {

    @Test
    public void test() {
        // 输入：matrix = [
        // ["1","0","1","0","0"],
        // ["1","0","1","1","1"],
        // ["1","1","1","1","1"],
        // ["1","0","0","1","0"]
        // ]
        // 输出：4
        char[][] matrix = new char[][]{
                {'1', '0', '1', '0', '0'}, {'1', '0', '1', '1', '1'}, {'1', '1', '1', '1', '1'}, {'1', '0', '0', '1', '0'}
        };
        System.out.println(maximalSquare(matrix));
    }


    public int maximalSquare(char[][] matrix) {
        int m = matrix.length;
        int n = matrix[0].length;

        int maxSide = 0;

        int[][] dp = new int[m][n];

        for (int i = 0; i < m; i++) {
            for (int j = 0; j < n; j++) {
                if (i == 0 || j == 0) {
                    // 第一行或者第一列
                    dp[i][j] = matrix[i][j] == '1' ? 1 : 0;
                } else if (matrix[i][j] == '0') {
                    // 如果这个点是0，那么正方形就断了
                    dp[i][j] = 0;
                } else {
                    // 这个点是1，那么正方形可以尝试继续
                    dp[i][j] = Math.min(Math.min(dp[i - 1][j], dp[i - 1][j - 1]), dp[i][j - 1]) + 1;
                }

                maxSide = Math.max(maxSide, dp[i][j]);
            }
        }


        return maxSide * maxSide;
    }

}


/*
1 0 1 0 0
1 0 1 1 1
1 1 1 1 1
1 0 0 1 0

官方题解动态规划思路:

这里的dp保存的是以matrix[i][j]为右下角的正方形的最大边长：

dp(i,j) = min( dp(i−1,j), dp(i−1,j−1), dp(i,j−1) ) + 1

tm的简直妙不可言。。。

我尝试用人话来描述一下，可以这么理解：
首先，
dp(i-1, j)   是寻找该点的上方。 ↑
dp(i-1, j-1) 是寻找该点的左上方 ↖
dp(i, j-1)   是寻找该点的左方   ←

其实可以想到的是，如果某个点想接着组成正方形，那么它的左上方、上方、左方都得至少是1。
否则就断掉了。

比如：
  (i) 0 1 2 3
(j) ---------
 0  | 1 1 1 1
 1  | 1 1 1 1
 2  | 1 1 1 0
 3  | 1 1 1 1
所以这三个值里面但凡有一个是0，那么这个 min() 函数得到就是 0 了，也就是断掉了。
比如你看 (3, 3) 这个点，其左方、左上方都是3，但是上方是0，所以这个点的正方形就组不成了，只能“从头再来“了。

都是1的情况下，说明这个点可以延续上方、左方、左上方的正方形，继续增大一个。
但是增大的面积又必须依赖于这三个值的最小值，因为一个方向大是没用的，必须是三个方向都能延续才行，这个整体的正方形才能继续增大1。
例如：
  (i) 0 1 2 3
(j) ---------
 0  | 0 1 1 1
 1  | 1 1 1 1
 2  | 1 1 1 1
 3  | 1 1 1 1

当计算最右下角(3,3)的一个1时，
其中:
左方， (2, 3) 的最大正方形大小为 3
上方， (3, 2) 的最大正方形大小为 3
但是~~~ 左上方 (2, 2) 的最大正方形大小为 2，这tm就导致左方和上方的3都前功尽弃了。
究其原因，就得返过去往回找，发现确实是因为最左上(0, 0)的 0导致的正方形组不成。

至于详细的证明过程，我恐怕无法给出，但是这个状态转移方程看完之后，觉得真的是“妙”啊。
那这样，这个题目就十分简单了。

状态转移方程如上，
dp(i,j) = min( dp(i−1,j), dp(i−1,j−1), dp(i,j−1) ) + 1

然后讨论一些特殊情况：
1. 当 i=0 或 j=0 时，也就是第一行或者第一列，matrix(i,j) 是 1 时，dp(i,j) = 1，否则 dp(i,j) = 0
2. 当这个点 matrix(i,j) 为 0 时，dp(i,j) = 0

最后，因为我们之前说过：
这里的dp保存的是以matrix[i][j]为右下角的正方形的最大边长。
所以返回dp矩阵中的最大值的平方即可。
*/
package com.veeja.leetCode.Q0601_Q0700;

import com.veeja.leetCode.util.ArrayUtil;
import org.junit.Test;

/**
 * 639. 解码方法 II
 * 一条包含字母 A-Z 的消息通过以下的方式进行了 编码 ：
 * <p>
 * 'A' -> "1"
 * 'B' -> "2"
 * ...
 * 'Z' -> "26"
 * 要 解码 一条已编码的消息，所有的数字都必须分组，然后按原来的编码方案反向映射回字母（可能存在多种方式）。例如，"11106" 可以映射为：
 * <p>
 * "AAJF" 对应分组 (1 1 10 6)
 * "KJF" 对应分组 (11 10 6)
 * 注意，像 (1 11 06) 这样的分组是无效的，因为 "06" 不可以映射为 'F' ，因为 "6" 与 "06" 不同。
 * <p>
 * 除了 上面描述的数字字母映射方案，编码消息中可能包含 '*' 字符，可以表示从 '1' 到 '9' 的任一数字（不包括 '0'）。例如，编码字符串 "1*" 可以表示 "11"、"12"、"13"、"14"、"15"、"16"、"17"、"18" 或 "19" 中的任意一条消息。对 "1*" 进行解码，相当于解码该字符串可以表示的任何编码消息。
 * <p>
 * 给你一个字符串 s ，由数字和 '*' 字符组成，返回 解码 该字符串的方法 数目 。
 * <p>
 * 由于答案数目可能非常大，返回 10^9 + 7 的 模 。
 * <p>
 * 示例 1：
 * 输入：s = "*"
 * 输出：9
 * 解释：这一条编码消息可以表示 "1"、"2"、"3"、"4"、"5"、"6"、"7"、"8" 或 "9" 中的任意一条。
 * 可以分别解码成字符串 "A"、"B"、"C"、"D"、"E"、"F"、"G"、"H" 和 "I" 。
 * 因此，"*" 总共有 9 种解码方法。
 * <p>
 * 示例 2：
 * 输入：s = "1*"
 * 输出：18
 * 解释：这一条编码消息可以表示 "11"、"12"、"13"、"14"、"15"、"16"、"17"、"18" 或 "19" 中的任意一条。
 * 每种消息都可以由 2 种方法解码（例如，"11" 可以解码成 "AA" 或 "K"）。
 * 因此，"1*" 共有 9 * 2 = 18 种解码方法。
 * <p>
 * 示例 3：
 * 输入：s = "2*"
 * 输出：15
 * 解释：这一条编码消息可以表示 "21"、"22"、"23"、"24"、"25"、"26"、"27"、"28" 或 "29" 中的任意一条。
 * "21"、"22"、"23"、"24"、"25" 和 "26" 由 2 种解码方法，但 "27"、"28" 和 "29" 仅有 1 种解码方法。
 * 因此，"2*" 共有 (6 * 2) + (3 * 1) = 12 + 3 = 15 种解码方法。
 */
public class Q0639 {

    @Test
    public void test1() {
        System.out.println("Result: " + numDecodings("*"));
        System.out.println("====================================");
    }

    @Test
    public void test2() {
        System.out.println("Result: " + numDecodings("1*"));
        System.out.println("====================================");
    }

    @Test
    public void test3() {
        System.out.println("Result: " + numDecodings("2*"));
        System.out.println("====================================");
    }

    @Test
    public void test4() {
        System.out.println("Result: " + numDecodings("1*2*3*"));
        System.out.println("====================================");
    }

    @Test
    public void test5() {
        System.out.println("Result: " + numDecodings("**"));
        System.out.println("====================================");
    }

    /**
     * s = "7*9*3*6*3*0*5*4*9*7*3*7*1*8*3*2*0*0*6*"
     * expect: 196465252
     */
    @Test
    public void test6() {
        System.out.println("Result: " + numDecodings("7*9*3*6*3*0*5*4*9*7*3*7*1*8*3*2*0*0*6*"));
        System.out.println("====================================");
    }

    public int numDecodings(String s) {
        int n = s.length();
        long[] dp = new long[n + 1];

        dp[0] = 1;

        if (s.startsWith("0")) {
            return 0;
        }

        for (int i = 1; i <= s.length(); i++) {

            char thisChar = s.charAt(i - 1); // * 1 2 3 4 5 6 7 8 9
            // System.out.println("thisChar: " + thisChar);

            if (i == 1) {
                // 对于第一位数字，如果是 * 的话，有9种解法，如果是数字的话，只有1种解法
                if (thisChar == '*') {
                    dp[i] = 9;
                } else {
                    dp[i] = 1;
                }
            } else {
                // 从第二位开始，要分情况讨论
                // 独立解码：
                long independent = 0;
                switch (thisChar) {
                    case '0':
                        // 如果这一位是0，不可能独立解码
                        independent = 0;
                        break;
                    case '*':
                        // 如果这一位是*，那么可以是1-9的任意一个数字
                        independent = dp[i - 1] * 9;
                        break;
                    default:
                        // 如果这一位是数字，那么只有一种解法
                        independent = dp[i - 1] * 1;
                }

                // 组合解码：
                long combined = 0;
                char lastChar = s.charAt(i - 1 - 1); // * 1 2 3 4 5 6 7 8 9
                switch (lastChar) {
                    // 上一位是 * 的情况
                    case '*':
                        switch (thisChar) {
                            case '*':
                                // 如果这一位是 * 的话，那么可以是 11-19,21-26 之间的任意一个数字， 15
                                combined = dp[i - 2] * 15;
                                break;
                            case '0':
                            case '1':
                            case '2':
                            case '3':
                            case '4':
                            case '5':
                            case '6':
                                // 如果这一位是 0-6 之间的数字，那么可以是 10-26 之间的任意一个数字，*可以取1或者2，2种情况
                                combined = dp[i - 2] * 2;
                                break;
                            case '7':
                            case '8':
                            case '9':
                            default:
                                // 如果这一位是 7-9 之间的数字，那么只能是 17-19 之间的数字，所以*只能取1，1种情况
                                combined = dp[i - 2] * 1;
                                break;
                        }
                        break;
                    // 上一位是0的情况
                    case '0':
                        // 上一位是0，不可能组合解码
                        combined = 0;
                        break;
                    // 上一位是1的情况，也需要分情况讨论
                    case '1':
                        if (thisChar == '*') {
                            // 如果这一位是 * 的话，那么可以是 1-9 之间的任意一个数字， 11-19 有9种解法
                            combined = dp[i - 2] * 9;
                        } else {
                            // 如果不是 * 的话，只有一种解法， 10-19的任意一个数字
                            combined = dp[i - 2] * 1;
                        }
                        break;
                    // 上一位是2的情况，也需要分情况讨论
                    case '2':
                        if (thisChar == '*') {
                            // 如果这一位是 * 的话，那么可以是 1-6 之间的任意一个数字， 21-26 有6种解法
                            combined = dp[i - 2] * 6;
                        } else if (thisChar <= '6') {
                            // 如果不是 * 的话，如果是 0-6 之间的数字，有1种解法
                            combined = dp[i - 2] * 1;
                        } else {
                            // 如果不是 * 的话，也不是 0-6 之间的数字，那么就是 7-9 之间的数字，没有解法
                            combined = 0;
                        }
                        break;
                    // 上一位是3-9的情况
                    case '3':
                    case '4':
                    case '5':
                    case '6':
                    case '7':
                    case '8':
                    case '9':
                    default:
                        // 如果上一位是 3-9 之间的数字，全部都是不可能的，没有解法
                        combined = 0;
                        break;
                }


                // 最后把 独立解码 和 组合解码 的解法加起来
                dp[i] = (independent + combined) % 1000000007;
            }
            // ArrayUtil.printArray(dp);

        }


        return (int) dp[n];
    }
}

/*
做这个题目之前，强烈建议先做 LeetCode 91（以下简称91），因为这个题是对 91 的扩展，91 是只有数字，这个题是 数字 和 *，所以我们可以把 * 当做是 1-9 的数字，然后对 91 解法进行扩展即可。

首先我们找个例子，题目中的例子设计的都不是很好，所以我们自己设计一个例子，

```
s = "1*2*3*"
```

首先呢，还是列出DP表：
```
i         |  0    1     2       3        4        5
s[i]      |  1    *     2       *        3        *
s[0..i]   |  1    1*    1*2     1*2*     1*2*3    1*2*3*
DP[i]     |
```

首先是 `DP[0]`, 此时 `s[0..0] = 1`，只有一种解码方法，所以 `DP[0] = 1`。

然后是 `DP[1]`，此时 `s[0..1] = 1*`，

这个时候我们先按照我们之前的思路，分成两种情况讨论：

将 `*` 当做独立个体，`*` 可以是 `1-9` 之间的任意一个数字，而前面的 `1` 只有一种情况，所以解法有 9 种。

其次，是将 `*` 和 前面的一位 也就是 `1` 组合在一起，这个时候 `*` 也可以是 `1-9` 之间的任意一个数字，跟前面的 `1` 可以组合成 `11-19` 这 9 种情况。

综合起来，`DP[1] = 9 + 9 = 18`。

先让我们更新一下 DP 表：

```
i         |  0    1     2       3        4        5
s[i]      |  1    *     2       *        3        *
s[0..i]   |  1    1*    1*2     1*2*     1*2*3    1*2*3*
DP[i]     |  1    18
```

然后我们看 `DP[2]`，此时 `s[0..2] = 1*2`，

我们继续分情况讨论：

将 `2` 作为一个独立个体，那么 `2` 只有一种解码方法，而前面的 `1*` 有 18 种解码方法，所以这种情况下有 18 种解码方法。

将 `2` 和前面的 `*` 组合在一起成为 `*2`，我们着重讨论一下这种情况： `*` 本身可以是 `1-9` 之间的任意一个数字，但是我们要考虑的是，`*` 和 `2` 组合在一起，`*` 就只有可能是 `1` 或者 `2` （也就是 12，22）, 3-9 的情况是不可能的，所以这种情况下只有 2 种解码方法。

综合起来，`DP[2] = 18 + 2 = 20`。

再次更新一下 DP 表：

```
i         |  0    1     2       3        4        5
s[i]      |  1    *     2       *        3        *
s[0..i]   |  1    1*    1*2     1*2*     1*2*3    1*2*3*
DP[i]     |  1    18    20
```

好，我们再来分析一下 `DP[3]`，此时 `s[0..3] = 1*2*`，

还是要分情况讨论：

将 `*` 作为独立个体，那么 `*` 可以是 `1-9` 之间的任意一个数字，而前面的 `1*2` 有 20 种解码方法，所以这种情况下有 20 * 9 = 180 种解码方法！！！

如果将 `*` 和前面的 `2` 组合在一起成为 `2*`，那么 `*` 可以是 `1-6` 之间的任意一个数字（也就是组成21-26），有6种情况。而前面的 `1*` 有18种情况。 所以这种情况下有 18 * 6 = 108 种解码方法。

综合起来，`DP[3] = 180 + 108 = 388`。

是不是感受到了爆炸，怎么解法忽然就非常的多了起来。

再次更新一下 DP 表：
```
i         |  0    1     2       3        4        5
s[i]      |  1    *     2       *        3        *
s[0..i]   |  1    1*    1*2     1*2*     1*2*3    1*2*3*
DP[i]     |  1    18    20      288
```

接着我们看 `DP[4]`，此时 `s[0..4] = 1*2*3`，

还是要分情况讨论：

将 `3` 作为独立个体，那么 `3` 只有一种解码方法，而前面的 `1*2*` 有 288 种解码方法，所以这种情况下有 288 种解码方法。

如果将 `3` 和前面的 `*` 组合在一起成为 `*3`，那么 `*` 可以是 1 或者 2，有2种情况。而前面的 `1*2` 有20种情况。所以这种情况下有 20 * 2 = 40 种解码方法。

综合起来，`DP[4] = 288 + 40 = 328`。

再次更新一下 DP 表：
```
i         |  0    1     2       3        4        5
s[i]      |  1    *     2       *        3        *
s[0..i]   |  1    1*    1*2     1*2*     1*2*3    1*2*3*
DP[i]     |  1    18    20      288      328
```

最后我们看 `DP[5]`，这也是一种相对特殊的情况，此时 `s[0..5] = 1*2*3*`，

还是要分情况讨论：

将 `*` 作为独立个体，那么 `*` 的解法为 9，而前面的 `1*2*3` 有 328 种解码方法，所以这种情况下有 328 * 9 = 2952 种解码方法!!!

如果将 `*` 和前面的 `3` 组合在一起成为 `3*`，这个时候，是无论如何都不可能的，因为就没有序号是三十几的，所以这种情况下是 0 种解码方法。

综合起来，`DP[5] = 2952 + 0 = 2952`。

最后我们得到的DP表是：
```
i         |  0    1     2       3        4        5
s[i]      |  1    *     2       *        3        *
s[0..i]   |  1    1*    1*2     1*2*     1*2*3    1*2*3*
DP[i]     |  1    18    20      288      328      2952
```

这个时候，我们就可以得到答案了，`2952`。

并且，这个题目里面的特殊情况，跟我们之前的91题是一样的，一旦出现了为解法为0的情况，那么就是0种解码方法，就可以直接返回0了。

还有一种情况就是 `**`，这个时候，我们可以把 `**` 当做是 `11-26` 之间的任意一个数字，所以解法是 `16` 种，不是 26 种，这个是需要注意的。

最后，可想而知的是，这个题目最后的结果可能非常的大，比如考虑这个字符串：

```
s = "1*2*3*4*5*6*7*8*9*0*1*2*3*4*5*6*7*8*9*0*1*2*3*4*5*6*7*8*9*0*1*2*3*4*5*6*7*8*9*0*1*2*3*4*5*6*7*8*9*0*1*2*3*4*5*6*7*8*9*0*1*2*3*4*5*6*7*8*9*0*1*2*3*4*5*6*7*8*9*0*1*2*3*4*5*6*7*8*9*0*1*2*3*4*5*6*7*8*9*0*
```

所以我们需要对结果取模，这个在题目里面也有提醒我们。
 */